var documenterSearchIndex = {"docs":
[{"location":"sigma/#SigmaPoints-1","page":"Sigma Points","title":"SigmaPoints","text":"","category":"section"},{"location":"sigma/#","page":"Sigma Points","title":"Sigma Points","text":"Modules = [SigmaPoints]\nPrivate = false","category":"page"},{"location":"sigma/#KalmanFilters.SigmaPoints.MerweScaled","page":"Sigma Points","title":"KalmanFilters.SigmaPoints.MerweScaled","text":"MerweScaled(\n    ;n::Int64, α::Float64, β::Float64, κ::Float64, residual_x::Function = -\n)\n\nParameters for the Van der Merwe's σ-points\n\nn::Int64: Dimensionality of the state. 2n+1 will be generated\nα::Float64: Spread of the σ-points around the mean.\nβ::Float64: Prior knowledge of the distribution of the mean.\nκ::Float64: Second scaling parameter.\nΣ_w::Array{Float64, 1}: Weights for each σ-point for the covariance.\nm_w::Array{Float64, 1}: Weights for each σ-point for the mean.\nresidual_x::Function = -: Function to compute residual between states.\n\n\n\n\n\n","category":"type"},{"location":"sigma/#KalmanFilters.SigmaPoints.calculate_σ_points-Tuple{}","page":"Sigma Points","title":"KalmanFilters.SigmaPoints.calculate_σ_points","text":"calculate_σ_points(\n    ;σ_parameters::MerweScaled, x::Array{Float64, 1}, P::Array{Float64, 2}\n)::Array{Float64, 2}\n\nCompute 2n+1 x n Van der Merwe's σ-points for an Unscented Kalman Filter (UKF) given the mean x and covariance P.\n\nArguments\n\nσ_parameters::MerweScaled: Parameters of the Van der Merwe's σ-points.\nx::Array{Float64, 1}: Mean of the UKF.\nP::Array{Float64, 2}: Covariance of the x of the UKF.\n\n\n\n\n\n","category":"method"},{"location":"sigma/#KalmanFilters.SigmaPoints.num_σ_points-Tuple{KalmanFilters.SigmaPoints.MerweScaled}","page":"Sigma Points","title":"KalmanFilters.SigmaPoints.num_σ_points","text":"num_σ_points(σ_parameters::MerweScaled)::Int64\n\nReturn number of σ-points for given σ-parameters.\n\n\n\n\n\n","category":"method"},{"location":"filters/#Unscented-Kalman-Filter-1","page":"Filters","title":"Unscented Kalman Filter","text":"","category":"section"},{"location":"filters/#","page":"Filters","title":"Filters","text":"Modules = [UnscentedKalmanFilter]\nPrivate = false","category":"page"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.UKFState","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.UKFState","text":"State of the Unscented Kalman Filter\n\ndim_x::Int64: State dimension\ndim_z::Int64: Measurement dimension\nx::AbstractArray{Float64, 1}: State of the filter\nP::AbstractArray{Float64, 2}: Covariance matrix of the filter.\nK::AbstractArray{Float64, 2}: Kalman gain of the filter.\nS::AbstractArray{Float64, 2}: System uncertainty.\nS_inv::AbstractArray{Float64, 2}: Inverse of system uncertainty.\nσ_parameters::MerweScaled: Parameters for Van der Merwe sigma points.\nσ_fx::AbstractArray{Float64, 2}: Sigma points after fx.\nσ_hx::AbstractArray{Float64, 2}: Sigma points after hx.\nadd_x::Function: Function to calculate addition between two states.\nresidual_x::Function: Function to calculate residual between two states.\nresidual_z::Function: Function to calculate residual between state and measurement.\nmean_x::Function: Function to calculate mean between Σ-points and weights   after passing them through fx.\nmean_z::Function: Function to calculate mean between Σ-points and weights   after passing them through hx.\n\n\n\n\n\n","category":"type"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.UKFState-Tuple{}","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.UKFState","text":"UKFState(\n    ;dim_x::Int64, dim_z::Int64, σ_parameters::MerweScaled,\n    add_x::Function = default_add_x,\n    residual_x::Function = default_residual,\n    residual_z::Function = default_residual,\n    mean_x::Function = default_mean_f,\n    mean_z::Function = default_mean_f,\n)\n\nArguments\n\ndim_x::Int64: State dimension\ndim_z::Int64: Measurement dimension\nσ_parameters::MerweScaled: Parameters for Van der Merwe sigma points.\nadd_x::Function:   Function to calculate addition between two states.   Should accept two positional arguments y and x   both of type AbstractArray{Float64, 1} and return AbstractArray{Float64, 1} as well.\nresidual_x::Function: Function to calculate residual between two states.   Should accept two positional arguments y and x,   but should have methods both for AbstractArray{Float64, 1}, AbstractArray{Float64, 1}   and for AbstractArray{Float64, 2}, AbstractArray{Float64, 1} types of arguments.   In second case, residual will be calculated between Σ-points   and state x and return matrix of the same shape as Σ.\nresidual_z::Function: Function to calculate residual between state and measurement.   Same as for residual_x, you should define methods for both kinds   of arguments.\nmean_x::Function: Function to calculate mean between Σ-points   and weights after passing them through fx.   Arguments are positional.\nmean_z::Function: Function to calculate mean between Σ-points   and weights after passing them through hx.   Arguments are positional.\n\nnote: Note\nDo not forget to implement methods for both kinds of arguments for residual_x and/or residual_z as described above.\n\n\n\n\n\n","category":"method"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.predict!-Tuple{}","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.predict!","text":"predict!(\n    ;ukf::UKFState, δt::Float64, Q::Union{Nothing, AbstractArray{Float64, 2}},\n    fx::Function, fx_args...\n)\n\nPerform prediction of the Unscented Kalman Filter (UKF). This updates x and P of the ukf to contain predicted state and covariance.\n\nArguments\n\nukf::UKFState: State of the UKF on which to perform prediction.\nδt::Float64: Time delta.\nQ::Union{Nothing, AbstractArray{Float64, 2}}: Process noise.\nfx::Function(;x::AbstractArray{Float64, 1}, δt::Float64, ...):   State transition function.   Should accept keyword-only arguments, with mandatory x and δt.   All other arguments may serve as control input or provide additional info.\nfx_args...: Arguments to pass to fx function.   Must contain at least x and δt arguments.\n\nnote: Note\nJust to emphasize, fx should accept keyword-only arguments, with mandatory x and δt. All other arguments may serve as control input or provide additional info.\n\n\n\n\n\n","category":"method"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.update!-Tuple{}","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.update!","text":"update!(\n    ;ukf::UKFState, z::AbstractArray{Float64, 1}, R::Union{Nothing, AbstractArray{Float64, 2}},\n    hx::Function, hx_args...\n)\n\nPerform update step of the Unscented Kalman Filter (UKF) given measurements. This updates x and P of the ukf_state to contain updated state and covariance.\n\nArguments\n\nukf::UKFState: State of the UKF on which to perform update step.\nz::AbstractArray{Float64, 1}: Measurements.\nR::Union{Nothing, AbstractArray{Float64, 2}}: Measurement noise.\nhx::Function:   Measurement function.   Should accept keyword-only arguments with mandatory x argument for state.   Given state x of UKF it must transform it to the respective measurement.\nhx_args...: Arguments that will be passed to hx function.   Should contain at least x argument.\n\nnote: Note\nJust to emphasize, hx should accept keyword-only arguments with mandatory x argument for state. Given state x of UKF it must transform it to the respective measurement.\n\n\n\n\n\n","category":"method"},{"location":"filters/#Default-functions-1","page":"Filters","title":"Default functions","text":"","category":"section"},{"location":"filters/#","page":"Filters","title":"Filters","text":"Modules = [UnscentedKalmanFilter.Helpers]\nPrivate = false","category":"page"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.Helpers.default_add_x-Tuple{AbstractArray{Float64,1},AbstractArray{Float64,1}}","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.Helpers.default_add_x","text":"Default addition function.\n\n\n\n\n\n","category":"method"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.Helpers.default_mean_f-Tuple{AbstractArray{Float64,2},AbstractArray{Float64,1}}","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.Helpers.default_mean_f","text":"Default mean function.\n\n\n\n\n\n","category":"method"},{"location":"filters/#KalmanFilters.UnscentedKalmanFilter.Helpers.default_residual-Tuple{AbstractArray{Float64,1},AbstractArray{Float64,1}}","page":"Filters","title":"KalmanFilters.UnscentedKalmanFilter.Helpers.default_residual","text":"Default residual function.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilters.jl-1","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"","category":"section"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"This library provides implementation of different Kalman Filters.","category":"page"},{"location":"#Example-1","page":"KalmanFilters.jl","title":"Example","text":"","category":"section"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"Minimal example with constant velocity model.","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"Necessary imports:","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"using LinearAlgebra: I, diagm\nusing KalmanFilters.UnscentedKalmanFilter\nusing KalmanFilters.SigmaPoints","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"Define state-transition function:","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"function fx(;x::Array{Float64, 1}, δt::Float64)::Array{Float64, 1}\n    F = Float64[[1 δt 0 0];[0 1 0 0];[0 0 1 δt];[0 0 0 1]]\n    F * x\nend","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"Define measurement function:","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"hx(;x::Array{Float64, 1})::Array{Float64, 1} = x[[1, 3]]","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"Create filter state, perform prediction and feed measurements to filter:","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"function main()\n    δt = 0.1\n    nstd = 0.1\n    σ_parameters = MerweScaled(n=4, α=0.1, β=2.0, κ=-1.0)\n    ukf = UKFState(dim_x=4, dim_z=2, σ_parameters=σ_parameters)\n    ukf.x[:] = [-1, 1, -1, 1]\n    ukf.P[:] *= 0.2\n    Q = [\n        [2.5e-09 5.0e-08 0.0e+00 0.0e+00];\n        [5.0e-08 1.0e-06 0.0e+00 0.0e+00];\n        [0.0e+00 0.0e+00 2.5e-09 5.0e-08];\n        [0.0e+00 0.0e+00 5.0e-08 1.0e-06];\n    ]\n    R = diagm([nstd ^ 2, nstd ^ 2])\n\n    measurements = vcat([[i + randn() * nstd i + randn() * nstd] for i = 1:10]...)\n    for i = 1:size(measurements, 1)\n        predict!(ukf=ukf, δt=δt, Q=Q, fx=fx)\n        update!(ukf=ukf, z=measurements[i, :], R=R, hx=hx)\n    end\n    println(ukf.x) # position should be around [10, 10] coordinate\nend\n\nmain()","category":"page"},{"location":"#","page":"KalmanFilters.jl","title":"KalmanFilters.jl","text":"note: Note\nThis package is still in development, more filters will be implemented in future.","category":"page"}]
}
